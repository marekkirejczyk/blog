---
title: "Formal Verification for n00bs -Part 5: Insights of eDSL for KEVM"
author: "Unknown author"
date: "Unknown date"
heroImage: "/images/posts/1*g_lv9fJTno_9Y71TIFzzjQ.jpeg"
# tags: [] # No tags generated
---

This is the fifth post of a series Formal Verification for n00bs:
 [Part 1: The K ecosystem]
[Part 2: Proving the correctness of a token]
[Part 3: A try to prevent classic hack with KLab]
[Part 4: Insights of language KP]
art 5: Insights of eDSL for KEVM

In this post, we will try to explain the basics of eDSL. As we have seen in part 4, semantics written directly in K is always large, even for very simply contracts. This is due to the necessity of describing the whole state of EVM which is large itself. Moreover, the fact that with K we work in the layer of EVM (NOT Solidity code) means that even making statements about elementary constructions like storage, dynamic objects (i.e. arrays) etc is not easy.

The eDSL is designed to overcome the above issues so to make writing specifications in K simpler. However, preserving the full expression power of language K.

The main idea of eDSL is as follows: you do not need to describe the behavior of such fields of the state description (see Part 4 for details) that behave in a standard way. You simply describe only these fields that are specific for your high-level semantics.

The second interesting helpful feature of eDSL is connected to the fact that very often you need to write not one but a few specifications for your contract. Moreover, these specifications usually tend to be very similar (i.e. they concern different cases of the same function). For this particular reason, eDSL provides a simple mechanism that allows you to state only differences between similar specifications.

Last but not least, eDSL provides a set of useful macros.

Let’s consider the following *batchTransfer* function (already mentioned in [part3](https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086) ):

Below is a specification in eDSL for the function above.

#### The specifications
Our specifications file describe three K statements. Let’s analyze them in turn:

#### 1. Lines 2–29: [batchTransfer]
Here we define the part of the state that describes **callData **(on other wors data field of a transaction or in yet another words — data to be parsed to arguments of the function). We do it using the set of macros, that mimic ABI data.

Then (in field **gas**, line 14), we declare that the starting amount of gas for this statement is 100,000. At line 14 we use local eDSL variable **{GASCAP}** that is set to 100,000 in line 83.

Finally we state that we do not care (**“_”**) about the value of the field **refund **of the state of EVM,** **neither before nor after the execution. All other fields (**callStack**, **storage**, **output** etc) of EVM specification are standard and described in a template file. (We used this [template file]
from Runtime Verification. Naturally, you can modify it or write your own.)

Besides descriptions of states of EVM, here we declare also a few assumptions about variables in the state before the executions. This is done (line 16–29) in the **requires** section, exactly in the same way as in pure K (see part 5 for details).

#### 2. Lines 31–42: [batchTransfer-success]
In lines, 31–42 (together with earlier declarations) we describe fields that must be changed (added, extended, overwritten) compared to the previous statement **[batchTrasfer]**.

So: for **[batchTransfer-success]** fields **callData**, **gas** and **refund** are described the same as in **[batchTransfer]**. New specific fields are: **k**, **statusCode**, **output** and **log**, described in lines 32–40.

An interesting point is the section **requires**. Notice that line 41 starts with **“+”**. It means that value of section **requires** for **[batchTransfer-success]** is the following:

which is the old **requires** section with new lines added (here only one line 42), taken from **“+requires”** section of **[batchTransfer-success]**.

Remark: if in line 41 one wrote **requires** instead of **+requires**, it would mean that the new section **requires** will overwrite the old one, instead of adding new lines at the end.

#### 3. [batchTransfer-success-1] — lines 45–74 (plus earlier declarations)
New (specific) **storage** field is added to declaration and **requires** section is extended by new lines (57–74).

#### Remark
We described three statements but it does not mean that all three are actually needed. Often we start with a simple specification just because it gives a good base for next specifications that — thanks to this — might be much simpler (remember that we only state differences between previous specifications!).

As you can see, in this post we have (using eDSL) declared similar semantics to that analyzed in [part 3](https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086) . The difference is that in the previous attempt we had to change the code of Solidity to get rid of dynamic arrays. This time the [original code]
is unchanged. We still give a semantics for a fixed length of the array, but this time it is declared in the specification (line 6). The ultimate (very non-trivial) goal: a formal verification for an arbitrary long dynamic arrays will be hopefully presented in the very next post.

**Verification:** To test a semantics given in eDSL, one must first generate appropriate K statements from it (details are [here](https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/resources/instructions.md) ) and then run the same tools as described in part 4.

One of the best features of eDSL is a set of useful macros that significantly speeds up the process of writing specifications (and the resultant specs are shorter, thus more readable). Here is a brief overview (more details are [here](https://github.com/runtimeverification/verified-smart-contracts/blob/master/resources/edsl.md) ) of some of them:

#### #abiCallData
Let us analyze the example of usage from our spec:

The above macro is meant to describe the field **callData** from the state of EVM. This field decribes name and arguments of a function just to be called. This description is pretty low-level (all details are [here](https://solidity.readthedocs.io/en/develop/abi-spec.html) ):

- first four bytes represent hash value of function signature (here **keccak256(“transfer(address[],uint256)”)**);
- next 32 bytes represent the location (address offset from the start of the argument block in memory, here: **0x40**) of the starting point of the data representing first argument **_receivers**;
- next 32 bytes represent value of **_value**;
- next 32 bytes represent the length of **_receivers**, followed by the actual values of this argument.

As you can see, with macro #abiCallData, you do not need to know all the above details of low-level calling functions of EVM. What is worth noting, is an observation that this notation lets you easily give names (here TO1_ID, TO2_ID, TO3_ID, TO4_ID, VALUE) for variables that you can further use to state various assumptions about them. See section **requires** for examples.

#### #array
Let’s look at:

that was used inside **#abiCallData**. Here we have hard-coded that we want to deal only with arrays of length 4 (in line 3 instead of a name for variable we put a constant), we have given names for these four elements of the array and stated that the address in memory of the data is not important for us (**“_”**).

#### #hashedLocation
Also making statements about storage is not trivial for EVM. Fortunately eDSL gives us convenient macro **#hashedLocation **used for example as follows in the storage field:

Here we state that:

- at certain place (described by the macro and analyzed below) value before execution (denoted as **BAL_FROM**) changes to (**BAL_FROM-VALUE**) after execution (recall that **VALUE** is the variable denoting the second input value of the call — see **#abiCallData** above);
- the macro **#hashedLocation({COMPILER}, {_BALANCES}, CALLER_ID)**is meant to denote the place in storage that keeps value of a mapping **balances **at the address of the caller. Once again: this is very non-trivial when want to use only low-level EVM references. To do that we would need to know that:for Solidity, the address in storage (for elements of maps) is computed with formula**keccak256(Key || Indx)**,where **“Key”** denotes the value of key, **“||”** — concatanation and **“Indx” **— the position of the mapping on the list of all variables of the contract (for our contract it is **1**).With macro **#hashedLocation** it is possible to state that without the above knowledge.On the occasion, let us notice that:* strings inside brace brackets **{}** refer to local eDSL variables defined at the bottom of the spec file. Here we set the index of mapping **balances** on the list of contract variables to 1 and also specify the name of language used to generate the byte-code. (It is needed because depending on the language, addressing for mappings in storage may be different.)* One of these local variables must be **code** denoting the whole byte-code to be analyzed!* CALLER_ID refers to a value in the field <caller> of the EVM state description. You can look at the [template file]
to make sure how it is defined.

</caller>Next time we will try to show some more complex examples of using eDSL and — more generally — show that to really do formal verification for hard cases, it is often not enough to state the high-level semantics to be proven. To be efficient you should think that a “proof assistant” is needed for the machinery. In practice it means that one have to write some intermediate statements that are not important on their own, but will help the ultimate statement to be proven.

Stay tuned!