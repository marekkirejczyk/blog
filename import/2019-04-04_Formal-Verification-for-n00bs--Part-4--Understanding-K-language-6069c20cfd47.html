<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Formal Verification for n00bs -Part 4: Understanding K language</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Formal Verification for n00bs -Part 4: Understanding K language</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is the fourth post of a series Formal Verification for n00bs:
Part 1: The K ecosystem
Part 2: Proving the correctness of a token
Part…
</section>
<section data-field="body" class="e-content">
<section name="9243" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fa8f" id="fa8f" class="graf graf--h3 graf--leading graf--title">Formal Verification for n00bs -Part 4: Understanding K language</h3><figure name="1008" id="1008" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*V3h684cLP98nDAALIbHJeg.jpeg" data-width="1200" data-height="802" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*V3h684cLP98nDAALIbHJeg.jpeg"></figure><p name="e0c9" id="e0c9" class="graf graf--p graf-after--figure">This is the fourth post of a series Formal Verification for n00bs:<br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--p-anchor" target="_blank">Part 1: The K ecosystem</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">Part 2: Proving the correctness of a token<br></a><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">Part 3: A try to prevent classic hack with KLab</a><br>Part 4: Understanding K language</p><p name="3314" id="3314" class="graf graf--p graf-after--p">In this post, we will try to explain how high-level semantics for EVM functions are described directly in K. Please recall that so far all considered semantics were written in ACT (see <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">part2</a> and <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">part3</a>), a DSL language (provided by KLAB) that generates semantics in K. The prover itself works with K, so understanding the basics of K should give you a better understanding of the whole process and help in aware working.</p><blockquote name="35d9" id="35d9" class="graf graf--blockquote graf-after--p">For more details: the ecosystem is described in <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--blockquote-anchor" target="_blank">part1</a></blockquote><h3 name="9b2a" id="9b2a" class="graf graf--h3 graf-after--blockquote">Example</h3><p name="133f" id="133f" class="graf graf--p graf-after--h3">Once again let’s look at the simple ERC20 like token implementation in Solidity:</p><figure name="8c76" id="8c76" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/bfe03333d12a63d5bf2953ad91f258f1.js.js"></script></figure><p name="2f28" id="2f28" class="graf graf--p graf-after--figure">We have already (<a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">part2</a>) prepared high-level semantics for <strong class="markup--strong markup--p-strong">transfer</strong> function (in ACT):</p><figure name="b4d5" id="b4d5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/399404f43b70202f6365f8ce2743dbf1.js.js"></script></figure><p name="d485" id="d485" class="graf graf--p graf-after--figure">This time we want to go one step deeper and have a look at generated K specification (in real two K specs are generated — one for the case when header <strong class="markup--strong markup--p-strong">iff</strong> is true and second when it is false. We will deal only with the first case). The K source is here:</p><figure name="7e63" id="7e63" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/ff77809917669b29af315c528ef05ee9.js.js"></script></figure><p name="c774" id="c774" class="graf graf--p graf-after--figure">It looks somewhat complex at first, so let’s go through it step by step.</p><h3 name="a076" id="a076" class="graf graf--h3 graf-after--p">An overview</h3><blockquote name="e78f" id="e78f" class="graf graf--blockquote graf-after--h3">Reminder: Semantics written in K refer to the EVM byte code of considerate contract, not to its Solidity source code.</blockquote><p name="0835" id="0835" class="graf graf--p graf-after--blockquote">The byte code itself is a part of K specification, what you can observe in lines 23, 24 and 69. That comes with pros and cons:<br>😄A proof is resistant to the potential compiler of Solidity bugs<br>😒 Writing specifications in K requires knowledge of the EVM.</p><h3 name="040e" id="040e" class="graf graf--h3 graf-after--p">Intended semantics</h3><p name="c2a7" id="c2a7" class="graf graf--p graf-after--h3">Let us recall the intended semantics (details were deliberated <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">here</a>) of the considerate function:</p><p name="e458" id="e458" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">The behavior of (in this specific case) </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">transfer(address To, uint Value):</em></strong><em class="markup--em markup--p-em"> <br>If we assume that </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">CALLER_ID</em></strong><em class="markup--em markup--p-em"> is different from </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">To</em></strong><em class="markup--em markup--p-em"> and, if both </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">(balanceOf[To] + Value)</em></strong><em class="markup--em markup--p-em"> and </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">(balanceOf[CALLER_ID]-Value)</em></strong><em class="markup--em markup--p-em"> are in range of uint256, then the value of </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">balanceOf[CALLER_ID]</em></strong><em class="markup--em markup--p-em"> decreases by </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Value</em></strong><em class="markup--em markup--p-em">, and </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">balances[To]</em></strong><em class="markup--em markup--p-em"> increases by </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Value.</em></strong></p><p name="7666" id="7666" class="graf graf--p graf-after--p">Well, above we have a few lines, while the according to semantics in K consists of 101 lines. This is mainly because (in K) we need to write the specification in the form:</p><blockquote name="6af2" id="6af2" class="graf graf--pullquote graf-after--p">If at some point an EVM starts its run in a state that fulfills assumptions A, then it must finish in a state that fulfills statements S.</blockquote><p name="abcb" id="abcb" class="graf graf--p graf-after--pullquote">Note that we have to precisely describe all details of assumptions A in terms of the exact state of EVM.</p><p name="d2df" id="d2df" class="graf graf--p graf-after--p">EVM state is a combination of many variables, exhausting all aspects of EVM execution:</p><ul class="postList"><li name="59a7" id="59a7" class="graf graf--li graf-after--p">current transaction details(<em class="markup--em markup--li-em">gasPrice</em>, origin)</li><li name="89f6" id="89f6" class="graf graf--li graf-after--li">execution (<em class="markup--em markup--li-em">localMemory</em>, memoryUsed, <em class="markup--em markup--li-em">callDepth</em>, pc, …)</li><li name="3b36" id="3b36" class="graf graf--li graf-after--li">block parameters (<em class="markup--em markup--li-em">coinbase</em>, <em class="markup--em markup--li-em">difficulty</em>, <em class="markup--em markup--li-em">timestamp</em>, etc)</li><li name="863c" id="863c" class="graf graf--li graf-after--li">what is called network environment i.e. global ethereum state (list of accounts and their balances, storages, and bytecodes)</li></ul><p name="180c" id="180c" class="graf graf--p graf-after--li">We don’t care about most of them most of the time, yet we have to fill all of them each time. This is why our spec is so large.</p><h3 name="9e7b" id="9e7b" class="graf graf--h3 graf-after--p">Syntax explained</h3><p name="d8bb" id="d8bb" class="graf graf--p graf-after--h3">As you can see the description of the EVM state is described in XML-style notation. So, we have fields like &lt;callStack&gt;, &lt;callData&gt;,&lt;gas&gt;, &lt;storage&gt; and others. The whole structure is defined by KEVM, which is EVM description in K.</p><p name="65e5" id="65e5" class="graf graf--p graf-after--p">We will give you a brief digest to understand standard specifications (for more details you can look <a href="https://github.com/kframework/evm-semantics" data-href="https://github.com/kframework/evm-semantics" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>).</p><ul class="postList"><li name="9fd1" id="9fd1" class="graf graf--li graf-after--p">The specification starts with a preamble: here we state general settings. Example from our case is the following:</li></ul><figure name="bfcf" id="bfcf" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/823f841530bfb9ad32929614471933a8.js.js"></script></figure><p name="7a25" id="7a25" class="graf graf--p graf-after--figure">Then, we have an <strong class="markup--strong markup--p-strong">&lt;ethereum&gt;</strong> field with two subfields: <strong class="markup--strong markup--p-strong">&lt;evm&gt;</strong> and <strong class="markup--strong markup--p-strong">&lt;network&gt;</strong>.</p><h4 name="d2da" id="d2da" class="graf graf--h4 graf-after--p">&lt;EVM&gt;</h4><p name="b46c" id="b46c" class="graf graf--p graf-after--h4">The field <strong class="markup--strong markup--p-strong">&lt;evm&gt;</strong> describes the state of the current running call. It has many subfields. We omit the description of all of them and just give a few examples (you can skip analyzing this list during the first reading):<br>* <strong class="markup--strong markup--p-strong">&lt;output&gt;</strong>, describes the output of the called function;<br><strong class="markup--strong markup--p-strong">* &lt;program&gt;</strong>, description of the code, given as a series of OpCodes;<br><strong class="markup--strong markup--p-strong">* &lt;programBytes&gt;</strong>, bytecode of the program (this is basically the same as the above but in a different format);<br><strong class="markup--strong markup--p-strong">* &lt;id&gt;</strong>, the address of the owner of the contract;<br><strong class="markup--strong markup--p-strong">* &lt;caller&gt;</strong>, the address of the current caller;<br><strong class="markup--strong markup--p-strong">* &lt;callData&gt;</strong>, description of data of the call (name of the functions and values of arguments);<br><strong class="markup--strong markup--p-strong">* &lt;wordStack&gt;</strong>, the stack of functions call for the current run;<br><strong class="markup--strong markup--p-strong">* &lt;callStack&gt;</strong>, another stack, keeping track of calls between contracts;<br><strong class="markup--strong markup--p-strong">* &lt;localMem&gt;</strong>, map of local memory;<br><strong class="markup--strong markup--p-strong">* &lt;pc&gt;</strong>, the current program counter (place in the code to be executed)<br><strong class="markup--strong markup--p-strong">* &lt;gas&gt;</strong>, amount of gas left for the current run;<br><strong class="markup--strong markup--p-strong">* &lt;log&gt;</strong>, list of log entries of the current run;<br>(Better understanding of these fields will give analyze of the semantics of our spec, which will follow in the next section.)</p><h3 name="59f1" id="59f1" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">&lt;network&gt;</strong></h3><ul class="postList"><li name="d3a4" id="d3a4" class="graf graf--li graf-after--h3">The field <strong class="markup--strong markup--li-strong">&lt;network&gt;</strong> describes global Ethereum state. The most important subfield here is the field <strong class="markup--strong markup--li-strong">&lt;accounts&gt;</strong>, consisting of a list of <strong class="markup--strong markup--li-strong">&lt;account&gt;</strong> fields.</li><li name="87c0" id="87c0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">&lt;account&gt; </strong>is<strong class="markup--strong markup--li-strong"> </strong>a field describing a particular account of the system (many of such can be defined in the field <strong class="markup--strong markup--li-strong">&lt;accounts&gt;</strong>). Each of them have the following subfields:<br>* <strong class="markup--strong markup--li-strong">&lt;acctID&gt;</strong> — address of the account;<br>* <strong class="markup--strong markup--li-strong">&lt;balance&gt;</strong> — available funds of the account;<br>* <strong class="markup--strong markup--li-strong">&lt;code&gt;</strong> — code of the account (if it is a contract);<br>*<strong class="markup--strong markup--li-strong"> &lt;storage&gt;</strong> — storage (memory that is persistent between different calls) of the account;<br>* <strong class="markup--strong markup--li-strong">&lt;nonce&gt;</strong><br>Usually, only one account is defined — the one that calls considered function. I.e. in our case we have:</li></ul><figure name="69a4" id="69a4" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/d509ae8e2f7716f4ac6cd0c40ba1c9e4.js.js"></script></figure><h4 name="7059" id="7059" class="graf graf--h4 graf-after--figure">Value of a field</h4><p name="d0d1" id="d0d1" class="graf graf--p graf-after--h4">All fields in our spec are filled with statements describing their values. We can have there either:</p><ul class="postList"><li name="9d8d" id="9d8d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">_</strong> (any value),</li><li name="b28b" id="b28b" class="graf graf--li graf-after--li">a variable (i.e. <strong class="markup--strong markup--li-strong">“CALLER_ID”</strong>)</li><li name="d9c9" id="d9c9" class="graf graf--li graf-after--li">a fixed value (i.e. <strong class="markup--strong markup--li-strong">“1”</strong>) or an expression narrowing set of values of the field in the state, by given mask<br>i.e.<strong class="markup--strong markup--li-strong">“#abiCallData(“transfer”, #address(ABI_To), #uint256(ABI_Value))”</strong>.</li></ul><p name="263e" id="263e" class="graf graf--p graf-after--li">The above states that in the state of EVM, we must have an ABI call. In our case such that:</p><ul class="postList"><li name="9337" id="9337" class="graf graf--li graf-after--p">the name of the function must be <strong class="markup--strong markup--li-strong">“transfer”</strong>;</li><li name="5e65" id="5e65" class="graf graf--li graf-after--li">the second argument is unrestricted unless it is an <em class="markup--em markup--li-em">address</em> (and if you want to refer to it, it is named as <strong class="markup--strong markup--li-strong">ABI_To</strong>);</li><li name="dc71" id="dc71" class="graf graf--li graf-after--li">the third argument is unrestricted unless it is uint256 (and if you want to refer to it, it is named as <strong class="markup--strong markup--li-strong">ABI_Value</strong>);</li></ul><h4 name="76d1" id="76d1" class="graf graf--h4 graf-after--li">Two states?</h4><p name="6282" id="6282" class="graf graf--p graf-after--h4">Before we proceed further we want to point out one comment:</p><p name="b205" id="b205" class="graf graf--p graf-after--p">We have already said that to provide high-level semantics in K, one must describe two states — before and after the execution. However, a fast glance at the K specification gives the impression that only one state is described. This is because of simplified notation that allows describing both states at once. Here, crucial for the syntax is the notation<strong class="markup--strong markup--p-strong"> “=&gt;”</strong>. Let’s define its meaning by example:</p><figure name="3444" id="3444" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/8bb3cd4c63a064aff30a174b291edaed.js.js"></script></figure><p name="a6f2" id="a6f2" class="graf graf--p graf-after--figure">The above line states that in the state before the execution, the field &lt;statusCode&gt; can be anything (“<strong class="markup--strong markup--p-strong">_”</strong> stand for “anything”), but after the execution, it must be EVMC_SUCCESS.</p><h3 name="afbe" id="afbe" class="graf graf--h3 graf-after--p">Our example</h3><p name="3d96" id="3d96" class="graf graf--p graf-after--h3">So, according to the above, what we really specify in our K file, informally is more like (for your convenience the description is interspersed with code snippets):</p><h4 name="8606" id="8606" class="graf graf--h4 graf-after--p">Informal description of K specification</h4><p name="8d1b" id="8d1b" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">IF at some point an EVM is in a state such that:</em></p><ul class="postList"><li name="0045" id="0045" class="graf graf--li graf-after--p">the byte code of a contract is the following: “0x60660604052600…..”;</li></ul><figure name="d8bd" id="d8bd" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/014a2157a7b6715466d80a8550a66591.js.js"></script></figure><ul class="postList"><li name="1cae" id="1cae" class="graf graf--li graf-after--figure">the ABI call to be called is an array of 68 bytes such that: the first four bytes are the prefix of hash value of function signature (keccak256(“transfer(address,unit256)”), the next 32 bytes are representation of address <strong class="markup--strong markup--li-strong">To</strong> and the last 32 bytes translate into the value of <strong class="markup--strong markup--li-strong">Value;</strong><br>[REMARK: in our spec this is realized in the field &lt;callData&gt; (line 27) by macros #abiCallData, #address and #uint256 that are parts of a <a href="https://github.com/kframework/evm-semantics/blob/master/edsl.md" data-href="https://github.com/kframework/evm-semantics/blob/master/edsl.md" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">supplementary module</a> of KEVM]</li></ul><figure name="9daa" id="9daa" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/d6e0b54fff69f4abed0cea41837e7ace.js.js"></script></figure><ul class="postList"><li name="e34c" id="e34c" class="graf graf--li graf-after--figure">the caller’s address is <strong class="markup--strong markup--li-strong">CALLER_ID</strong>;</li></ul><figure name="5911" id="5911" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/f391e0feff3c1c8fdd646b18ab075b17.js.js"></script></figure><ul class="postList"><li name="f752" id="f752" class="graf graf--li graf-after--figure">the value of storage at position <strong class="markup--strong markup--li-strong">hash(CALLER_ID ++ “0”)</strong> is equal to <strong class="markup--strong markup--li-strong">FromBal;<br></strong>[Remark: the locations of storage in EVM are somewhat complicated. In above ++ stands for byte-array concatenation, the uint “0” is used because the mapping balanceOf is the very first in the source file so it has index 0. Details can be found <a href="https://jellopaper.org/edsl/?highlight=storage#hashed-location-for-storage" data-href="https://jellopaper.org/edsl/?highlight=storage#hashed-location-for-storage" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">here</a>. In our spec this is realized in the field &lt;storage&gt; (line 70) by macros #Token and #hashedLocation]</li></ul><figure name="1c9a" id="1c9a" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/66a3559e8c6bf943aaf1d8d3d6af257e.js.js"></script></figure><ul class="postList"><li name="aed8" id="aed8" class="graf graf--li graf-after--figure">the value of storage at position <strong class="markup--strong markup--li-strong">hash(To ++ “0”)</strong> is equal to <strong class="markup--strong markup--li-strong">ToBal;</strong></li><li name="502c" id="502c" class="graf graf--li graf-after--li">the depth of call stack is equal to <strong class="markup--strong markup--li-strong">VCallValue;</strong></li></ul><figure name="3e32" id="3e32" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/6e5d3d949bf38e28c62f20456e67a4bb.js.js"></script></figure><ul class="postList"><li name="cf3e" id="cf3e" class="graf graf--li graf-after--figure">the Gas limit is equal to <strong class="markup--strong markup--li-strong">VGas</strong>;</li></ul><figure name="9292" id="9292" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/ad5497e5b717fffb74596adb3aaffa99.js.js"></script></figure><ul class="postList"><li name="0d93" id="0d93" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">VCallValue</strong> is equal to 0; <strong class="markup--strong markup--li-strong">VGas</strong> is not smaller than 3000000;</li></ul><figure name="3905" id="3905" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/6634ccdf1ad3dffebd292cce55ee1315.js.js"></script></figure><ul class="postList"><li name="2ff3" id="2ff3" class="graf graf--li graf-after--figure">both <strong class="markup--strong markup--li-strong">FromBal-Value</strong> and <strong class="markup--strong markup--li-strong">ToBal+Value </strong>fit the range of uint256;</li></ul><figure name="c9d9" id="c9d9" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/b6230e63f75db63252339a37b06d30f1.js.js"></script></figure><ul class="postList"><li name="a41a" id="a41a" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">CALLER_ID</strong> is not equal <strong class="markup--strong markup--li-strong">To</strong>;</li></ul><figure name="eb7b" id="eb7b" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/3f08f6eb657639ed40f384a4d110c007.js.js"></script></figure><ul class="postList"><li name="c62e" id="c62e" class="graf graf--li graf-after--figure">…</li></ul><p name="0d96" id="0d96" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">THEN: If the execution halts, the status code of EVM is always EVMC_SUCCESS. The resulting state of EVM MUST fulfill:</em></p><ul class="postList"><li name="6b7b" id="6b7b" class="graf graf--li graf-after--p">the value of storage at position <strong class="markup--strong markup--li-strong">hash(CALLER_ID ++ “0”)</strong> is equal to <strong class="markup--strong markup--li-strong">FromBal-Value;</strong></li><li name="e568" id="e568" class="graf graf--li graf-after--li">the value of storage at position <strong class="markup--strong markup--li-strong">hash(To ++ “0”)</strong> is equal to <strong class="markup--strong markup--li-strong">ToBal+Value;</strong></li></ul><figure name="cb7d" id="cb7d" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/66a3559e8c6bf943aaf1d8d3d6af257e.js.js"></script></figure><h4 name="438c" id="438c" class="graf graf--h4 graf-after--figure">Remarks</h4><p name="f186" id="f186" class="graf graf--p graf-after--h4">The above (informal) description of the specification is long, despite that anyway it is slightly simplified! However, the main observation is that the specification is large because the <strong class="markup--strong markup--p-strong">whole state of EVM</strong> must be described. On the other hand — the largest part of the specification is not really specific but just describes the standard setting.</p><h3 name="de87" id="de87" class="graf graf--h3 graf--startsWithDoubleQuote graf-after--p">“requires” at the very end</h3><p name="6425" id="6425" class="graf graf--p graf-after--h3">As you can see in the K source file, after the description of the states there is a keyword <strong class="markup--strong markup--p-strong">requires </strong>(line 81)<strong class="markup--strong markup--p-strong"> </strong>followed by a few logical statements about variables used in the description of the states. This is the place in the specification where various assumptions can be stated: usually in the state-description part of the spec, we just name variables, but the actual assumptions about the state <strong class="markup--strong markup--p-strong">before</strong> execution are made here, in the <strong class="markup--strong markup--p-strong">requires</strong> section.</p><p name="80db" id="80db" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">REMARK</strong>: Besides “<strong class="markup--strong markup--p-strong">requires</strong>” section, you can also add “<strong class="markup--strong markup--p-strong">ensures</strong>” section, where you can add statements about the state <strong class="markup--strong markup--p-strong">after</strong> the execution. In our case, it was not needed, since the statement about storage is already covered by the field <strong class="markup--strong markup--p-strong">&lt;storage&gt;</strong> (line 70–71) of the state description. Find <strong class="markup--strong markup--p-strong">“=&gt;”</strong> in the description and try to think out what is declared here (also: the above informal description should help you).</p><h3 name="1fbe" id="1fbe" class="graf graf--h3 graf-after--p">Running the verification</h3><p name="8d84" id="8d84" class="graf graf--p graf-after--h3">To run the verification, one must install <a href="https://github.com/kframework/evm-semantics" data-href="https://github.com/kframework/evm-semantics" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">KEVM</a> and run <strong class="markup--strong markup--p-strong">kprove</strong>. Details are <a href="https://github.com/kframework/evm-semantics" data-href="https://github.com/kframework/evm-semantics" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><h3 name="7fd5" id="7fd5" class="graf graf--h3 graf-after--p">What next?</h3><p name="41e5" id="41e5" class="graf graf--p graf-after--h3">Until now we have seen formal specifications written in ACT (see <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">part2</a> and <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">part3</a>) and directly in K (this post). The first is very promising but has a long way to go. On the other hand — K is very technical and too many details need to be stated. Something in the middle is eDSL — another simple language to generate K statements, but with the following features:</p><ul class="postList"><li name="048b" id="048b" class="graf graf--li graf-after--p">anything you can state in K, is also possible to state in eDSL (in real, eDSL is more like a tool simplifying the process of writing directly in K, by providing useful macros and template mechanisms);</li><li name="4f53" id="4f53" class="graf graf--li graf-after--li">the description is much shorter than generated spec in K.</li></ul><p name="5c0f" id="5c0f" class="graf graf--p graf-after--li graf--trailing">So: next time we will focus on eDSL. Stay tuned!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@marekkirejczyk" class="p-author h-card">Marek Kirejczyk</a> on <a href="https://medium.com/p/6069c20cfd47"><time class="dt-published" datetime="2019-04-04T08:48:37.601Z">April 4, 2019</time></a>.</p><p><a href="https://medium.com/@marekkirejczyk/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 22, 2025.</p></footer></article></body></html>