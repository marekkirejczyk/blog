<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Formal Verification for n00bs -Part 5: Insights of eDSL for KEVM</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Formal Verification for n00bs -Part 5: Insights of eDSL for KEVM</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is the fifth post of a series Formal Verification for n00bs:
Part 1: The K ecosystem
Part 2: Proving the correctness of a token
Part…
</section>
<section data-field="body" class="e-content">
<section name="6e20" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="b6ee" id="b6ee" class="graf graf--figure graf--leading"><img class="graf-image" data-image-id="1*g_lv9fJTno_9Y71TIFzzjQ.jpeg" data-width="640" data-height="427" src="https://cdn-images-1.medium.com/max/800/1*g_lv9fJTno_9Y71TIFzzjQ.jpeg"></figure><h3 name="8c79" id="8c79" class="graf graf--h3 graf-after--figure graf--title">Formal Verification for n00bs -Part 5: Insights of eDSL for KEVM</h3><p name="d2ed" id="d2ed" class="graf graf--p graf-after--h3">This is the fifth post of a series Formal Verification for n00bs:<br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--p-anchor" target="_blank">Part 1: The K ecosystem</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">Part 2: Proving the correctness of a token</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">Part 3: A try to prevent classic hack with KLab</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" class="markup--anchor markup--p-anchor" target="_blank">Part 4: Insights of language K<br>P</a>art 5: Insights of eDSL for KEVM</p><p name="62ae" id="62ae" class="graf graf--p graf-after--p">In this post, we will try to explain the basics of eDSL. As we have seen in part 4, semantics written directly in K is always large, even for very simply contracts. This is due to the necessity of describing the whole state of EVM which is large itself. Moreover, the fact that with K we work in the layer of EVM (NOT Solidity code) means that even making statements about elementary constructions like storage, dynamic objects (i.e. arrays) etc is not easy. </p><p name="9800" id="9800" class="graf graf--p graf-after--p">The eDSL is designed to overcome the above issues so to make writing specifications in K simpler. However, preserving the full expression power of language K.</p><h3 name="d3cb" id="d3cb" class="graf graf--h3 graf-after--p">Main idea</h3><p name="1ba2" id="1ba2" class="graf graf--p graf-after--h3">The main idea of eDSL is as follows: you do not need to describe the behavior of such fields of the state description (see Part 4 for details) that behave in a standard way. You simply describe only these fields that are specific for your high-level semantics. </p><p name="03de" id="03de" class="graf graf--p graf-after--p">The second interesting helpful feature of eDSL is connected to the fact that very often you need to write not one but a few specifications for your contract. Moreover, these specifications usually tend to be very similar (i.e. they concern different cases of the same function). For this particular reason, eDSL provides a simple mechanism that allows you to state only differences between similar specifications.</p><p name="3040" id="3040" class="graf graf--p graf-after--p">Last but not least, eDSL provides a set of useful macros.</p><h3 name="dd43" id="dd43" class="graf graf--h3 graf-after--p">Example</h3><p name="d480" id="d480" class="graf graf--p graf-after--h3">Let’s consider the following <em class="markup--em markup--p-em">batchTransfer</em> function (already mentioned in <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">part3</a>):</p><figure name="87b8" id="87b8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/8671c4fae2df01eff9fa26de040c1465.js.js"></script></figure><p name="1db1" id="1db1" class="graf graf--p graf-after--figure">Below is a specification in eDSL for the function above.</p><figure name="b194" id="b194" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/c2c3985800b7f0b061ae5aa2a88da92f.js.js"></script></figure><h4 name="52cd" id="52cd" class="graf graf--h4 graf-after--figure">The specifications</h4><p name="7d0b" id="7d0b" class="graf graf--p graf-after--h4">Our specifications file describe three K statements. Let’s analyze them in turn:</p><h4 name="0f9c" id="0f9c" class="graf graf--h4 graf-after--p">1. Lines 2–29: [batchTransfer]</h4><p name="2f0d" id="2f0d" class="graf graf--p graf-after--h4">Here we define the part of the state that describes <strong class="markup--strong markup--p-strong">callData </strong>(on other wors data field of a transaction or in yet another words — data to be parsed to arguments of the function). We do it using the set of macros, that mimic ABI data.</p><p name="3ab1" id="3ab1" class="graf graf--p graf-after--p">Then (in field <strong class="markup--strong markup--p-strong">gas</strong>, line 14), we declare that the starting amount of gas for this statement is 100,000. At line 14 we use local eDSL variable <strong class="markup--strong markup--p-strong">{GASCAP}</strong> that is set to 100,000 in line 83. </p><p name="9c67" id="9c67" class="graf graf--p graf-after--p">Finally we state that we do not care (<strong class="markup--strong markup--p-strong">“_”</strong>) about the value of the field <strong class="markup--strong markup--p-strong">refund </strong>of the state of EVM,<strong class="markup--strong markup--p-strong"> </strong>neither before nor after the execution. All other fields (<strong class="markup--strong markup--p-strong">callStack</strong>, <strong class="markup--strong markup--p-strong">storage</strong>, <strong class="markup--strong markup--p-strong">output</strong> etc) of EVM specification are standard and described in a template file. (We used this <a href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/erc20/spec-tmpl.k" data-href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/erc20/spec-tmpl.k" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">template file</a> from Runtime Verification. Naturally, you can modify it or write your own.) </p><p name="6f5e" id="6f5e" class="graf graf--p graf-after--p">Besides descriptions of states of EVM, here we declare also a few assumptions about variables in the state before the executions. This is done (line 16–29) in the <strong class="markup--strong markup--p-strong">requires</strong> section, exactly in the same way as in pure K (see part 5 for details).</p><h4 name="5b62" id="5b62" class="graf graf--h4 graf-after--p">2. Lines 31–42: [batchTransfer-success]</h4><p name="2832" id="2832" class="graf graf--p graf-after--h4">In lines, 31–42 (together with earlier declarations) we describe fields that must be changed (added, extended, overwritten) compared to the previous statement <strong class="markup--strong markup--p-strong">[batchTrasfer]</strong>.</p><p name="96f0" id="96f0" class="graf graf--p graf-after--p">So: for <strong class="markup--strong markup--p-strong">[batchTransfer-success]</strong> fields <strong class="markup--strong markup--p-strong">callData</strong>, <strong class="markup--strong markup--p-strong">gas</strong> and <strong class="markup--strong markup--p-strong">refund</strong> are described the same as in <strong class="markup--strong markup--p-strong">[batchTransfer]</strong>. New specific fields are: <strong class="markup--strong markup--p-strong">k</strong>, <strong class="markup--strong markup--p-strong">statusCode</strong>, <strong class="markup--strong markup--p-strong">output</strong> and <strong class="markup--strong markup--p-strong">log</strong>, described in lines 32–40.</p><p name="5dc0" id="5dc0" class="graf graf--p graf-after--p">An interesting point is the section <strong class="markup--strong markup--p-strong">requires</strong>. Notice that line 41 starts with <strong class="markup--strong markup--p-strong">“+”</strong>. It means that value of section <strong class="markup--strong markup--p-strong">requires</strong> for <strong class="markup--strong markup--p-strong">[batchTransfer-success]</strong> is the following:</p><figure name="c48d" id="c48d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/a2b0ec84b8697451ce09e56682a84762.js.js"></script></figure><p name="3523" id="3523" class="graf graf--p graf-after--figure">which is the old <strong class="markup--strong markup--p-strong">requires</strong> section with new lines added (here only one line 42), taken from <strong class="markup--strong markup--p-strong">“+requires”</strong> section of <strong class="markup--strong markup--p-strong">[batchTransfer-success]</strong>.</p><p name="5c79" id="5c79" class="graf graf--p graf-after--p">Remark: if in line 41 one wrote <strong class="markup--strong markup--p-strong">requires</strong> instead of <strong class="markup--strong markup--p-strong">+requires</strong>, it would mean that the new section <strong class="markup--strong markup--p-strong">requires</strong> will overwrite the old one, instead of adding new lines at the end.</p><h4 name="5a2f" id="5a2f" class="graf graf--h4 graf-after--p">3. [batchTransfer-success-1] — lines 45–74 (plus earlier declarations)</h4><p name="a85b" id="a85b" class="graf graf--p graf-after--h4">New (specific) <strong class="markup--strong markup--p-strong">storage</strong> field is added to declaration and <strong class="markup--strong markup--p-strong">requires</strong> section is extended by new lines (57–74).</p><h4 name="9784" id="9784" class="graf graf--h4 graf-after--p">Remark</h4><p name="a9a9" id="a9a9" class="graf graf--p graf-after--h4">We described three statements but it does not mean that all three are actually needed. Often we start with a simple specification just because it gives a good base for next specifications that — thanks to this — might be much simpler (remember that we only state differences between previous specifications!).</p><h3 name="d004" id="d004" class="graf graf--h3 graf-after--p">What we declared here?</h3><p name="fa93" id="fa93" class="graf graf--p graf-after--h3">As you can see, in this post we have (using eDSL) declared similar semantics to that analyzed in <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="markup--anchor markup--p-anchor" target="_blank">part 3</a>. The difference is that in the previous attempt we had to change the code of Solidity to get rid of dynamic arrays. This time the <a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" data-href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">original code</a> is unchanged. We still give a semantics for a fixed length of the array, but this time it is declared in the specification (line 6). The ultimate (very non-trivial) goal: a formal verification for an arbitrary long dynamic arrays will be hopefully presented in the very next post.</p><p name="8b32" id="8b32" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Verification:</strong> To test a semantics given in eDSL, one must first generate appropriate K statements from it (details are <a href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/resources/instructions.md" data-href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/resources/instructions.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>) and then run the same tools as described in part 4.</p><h3 name="fb62" id="fb62" class="graf graf--h3 graf-after--p">Useful macros</h3><p name="bc44" id="bc44" class="graf graf--p graf-after--h3">One of the best features of eDSL is a set of useful macros that significantly speeds up the process of writing specifications (and the resultant specs are shorter, thus more readable). Here is a brief overview (more details are <a href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/resources/edsl.md" data-href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/resources/edsl.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>) of some of them:</p><h4 name="b0e2" id="b0e2" class="graf graf--h4 graf-after--p">#abiCallData</h4><p name="38cd" id="38cd" class="graf graf--p graf-after--h4">Let us analyze the example of usage from our spec:</p><figure name="1ff5" id="1ff5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/ea94013056a2d42d9dcbbc01e6295537.js.js"></script></figure><p name="bff6" id="bff6" class="graf graf--p graf-after--figure">The above macro is meant to describe the field <strong class="markup--strong markup--p-strong">callData</strong> from the state of EVM. This field decribes name and arguments of a function just to be called. This description is pretty low-level (all details are <a href="https://solidity.readthedocs.io/en/develop/abi-spec.html" data-href="https://solidity.readthedocs.io/en/develop/abi-spec.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>): </p><ul class="postList"><li name="3700" id="3700" class="graf graf--li graf-after--p">first four bytes represent hash value of function signature (here <strong class="markup--strong markup--li-strong">keccak256(“transfer(address[],uint256)”)</strong>);</li><li name="bdfa" id="bdfa" class="graf graf--li graf-after--li">next 32 bytes represent the location (address offset from the start of the argument block in memory, here: <strong class="markup--strong markup--li-strong">0x40</strong>) of the starting point of the data representing first argument <strong class="markup--strong markup--li-strong">_receivers</strong>;</li><li name="3b28" id="3b28" class="graf graf--li graf-after--li">next 32 bytes represent value of <strong class="markup--strong markup--li-strong">_value</strong>;</li><li name="8210" id="8210" class="graf graf--li graf-after--li">next 32 bytes represent the length of <strong class="markup--strong markup--li-strong">_receivers</strong>, followed by the actual values of this argument.</li></ul><p name="d669" id="d669" class="graf graf--p graf-after--li">As you can see, with macro #abiCallData, you do not need to know all the above details of low-level calling functions of EVM. What is worth noting, is an observation that this notation lets you easily give names (here TO1_ID, TO2_ID, TO3_ID, TO4_ID, VALUE) for variables that you can further use to state various assumptions about them. See section <strong class="markup--strong markup--p-strong">requires</strong> for examples.</p><h4 name="bfe8" id="bfe8" class="graf graf--h4 graf-after--p">#array</h4><p name="1ba7" id="1ba7" class="graf graf--p graf-after--h4">Let’s look at:</p><figure name="7141" id="7141" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/cfb4953f72dc0f1d4495c84439ba86dd.js.js"></script></figure><p name="afc2" id="afc2" class="graf graf--p graf-after--figure">that was used inside <strong class="markup--strong markup--p-strong">#abiCallData</strong>. Here we have hard-coded that we want to deal only with arrays of length 4 (in line 3 instead of a name for variable we put a constant), we have given names for these four elements of the array and stated that the address in memory of the data is not important for us (<strong class="markup--strong markup--p-strong">“_”</strong>).</p><h4 name="f372" id="f372" class="graf graf--h4 graf-after--p">#hashedLocation</h4><p name="71ad" id="71ad" class="graf graf--p graf-after--h4">Also making statements about storage is not trivial for EVM. Fortunately eDSL gives us convenient macro <strong class="markup--strong markup--p-strong">#hashedLocation </strong>used for example as follows in the storage field:</p><figure name="c09f" id="c09f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/6476ad81fcd58357fb6e3b04f1b73414.js.js"></script></figure><p name="600c" id="600c" class="graf graf--p graf-after--figure">Here we state that:</p><ul class="postList"><li name="e2c0" id="e2c0" class="graf graf--li graf-after--p">at certain place (described by the macro and analyzed below) value before execution (denoted as <strong class="markup--strong markup--li-strong">BAL_FROM</strong>) changes to (<strong class="markup--strong markup--li-strong">BAL_FROM-VALUE</strong>) after execution (recall that <strong class="markup--strong markup--li-strong">VALUE</strong> is the variable denoting the second input value of the call — see <strong class="markup--strong markup--li-strong">#abiCallData</strong> above);</li><li name="6280" id="6280" class="graf graf--li graf-after--li">the macro <br><strong class="markup--strong markup--li-strong">#hashedLocation({COMPILER}, {_BALANCES}, CALLER_ID)<br></strong>is meant to denote the place in storage that keeps value of a mapping <strong class="markup--strong markup--li-strong">balances </strong>at the address of the caller. Once again: this is very non-trivial when want to use only low-level EVM references. To do that we would need to know that:<br>for Solidity, the address in storage (for elements of maps) is computed with formula<br><strong class="markup--strong markup--li-strong">keccak256(Key || Indx)</strong>,<br>where <strong class="markup--strong markup--li-strong">“Key”</strong> denotes the value of key, <strong class="markup--strong markup--li-strong">“||”</strong> — concatanation and <strong class="markup--strong markup--li-strong">“Indx” </strong>— the position of the mapping on the list of all variables of the contract (for our contract it is <strong class="markup--strong markup--li-strong">1</strong>).<br>With macro <strong class="markup--strong markup--li-strong">#hashedLocation</strong> it is possible to state that without the above knowledge.<br>On the occasion, let us notice that:<br>* strings inside brace brackets <strong class="markup--strong markup--li-strong">{}</strong> refer to local eDSL variables defined at the bottom of the spec file. Here we set the index of mapping <strong class="markup--strong markup--li-strong">balances</strong> on the list of contract variables to 1 and also specify the name of language used to generate the byte-code. (It is needed because depending on the language, addressing for mappings in storage may be different.)<br>* One of these local variables must be <strong class="markup--strong markup--li-strong">code</strong> denoting the whole byte-code to be analyzed!<br>* CALLER_ID refers to a value in the field &lt;caller&gt; of the EVM state description. You can look at the <a href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/erc20/spec-tmpl.k" data-href="https://github.com/runtimeverification/verified-smart-contracts/blob/c4b642c163346a5d2562585ac5f9f94adc01a99a/erc20/spec-tmpl.k" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">template file</a> to make sure how it is defined.</li></ul><h3 name="d7ae" id="d7ae" class="graf graf--h3 graf-after--li">What next?</h3><p name="245e" id="245e" class="graf graf--p graf-after--h3">Next time we will try to show some more complex examples of using eDSL and — more generally — show that to really do formal verification for hard cases, it is often not enough to state the high-level semantics to be proven. To be efficient you should think that a “proof assistant” is needed for the machinery. In practice it means that one have to write some intermediate statements that are not important on their own, but will help the ultimate statement to be proven.</p><p name="6109" id="6109" class="graf graf--p graf-after--p">Stay tuned!</p><p name="2916" id="2916" class="graf graf--p graf--empty graf-after--p graf--trailing"><br></p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/4c18ee78e0f4">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 22, 2025.</p></footer></article></body></html>