<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Formal Verification for n00bs -Part 2: proving the correctness of a token</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Formal Verification for n00bs -Part 2: proving the correctness of a token</h1>
</header>
<section data-field="subtitle" class="p-summary">
An example of a high-level semantics of a single function of an Ethereum smart contract and a step-by-step guide for executing the proof.
</section>
<section data-field="body" class="e-content">
<section name="df63" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2bad" id="2bad" class="graf graf--h3 graf--leading graf--title">Formal Verification for n00bs -Part 2: proving the correctness of a token</h3><figure name="7cc4" id="7cc4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*SCqqcStV-C1RNfeWh__YgA.png" data-width="600" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*SCqqcStV-C1RNfeWh__YgA.png"></figure><p name="813b" id="813b" class="graf graf--p graf-after--figure">This is the second post of a series Formal Verification for n00bs:<br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--p-anchor" target="_blank">Part 1: The K ecosystem</a><br>Part 2: Proving the correctness of a token<br><a href="http://Formal%20Verification%20for%20n00bs%20-Part%203:%20An%20attempt%20to%20prevent%20classic%20hack%20with%20Act" data-href="http://Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with Act" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Part 3: Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with Act</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" class="markup--anchor markup--p-anchor" target="_blank">Part 4: Understanding K language</a></p><p name="4af0" id="4af0" class="graf graf--p graf-after--p">In this post, we will explain an example of a high-level semantics of a single function of an Ethereum smart contract and a step-by-step guide for executing the proof.</p><p name="41e6" id="41e6" class="graf graf--p graf-after--p">We will take a look at an official example given by KLAB in their GitHub repository of a transfer function for a simple token.</p><h3 name="cc50" id="cc50" class="graf graf--h3 graf-after--p">Example</h3><p name="c0d4" id="c0d4" class="graf graf--p graf-after--h3">The first important file is the source file of the analyzed contract <a href="https://github.com/dapphub/klab/blob/master/examples/token/dapp/src/token.sol" data-href="https://github.com/dapphub/klab/blob/master/examples/token/dapp/src/token.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">token.sol</a>, see below.</p><figure name="85a0" id="85a0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/bfe03333d12a63d5bf2953ad91f258f1.js.js"></script></figure><p name="aa25" id="aa25" class="graf graf--p graf-after--figure">Second important file is high-level semantics of a function <strong class="markup--strong markup--p-strong">transfer</strong> from the <strong class="markup--strong markup--p-strong">Token</strong> contract above. File <a href="https://github.com/dapphub/klab/blob/master/examples/token/src/spec.md" data-href="https://github.com/dapphub/klab/blob/master/examples/token/src/spec.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">spec.md</a> contains semantics written in ACT, a specific DSL language, created by KLAB. See below.</p><figure name="54e8" id="54e8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/399404f43b70202f6365f8ce2743dbf1.js.js"></script></figure><h3 name="8b44" id="8b44" class="graf graf--h3 graf-after--figure">Semantics step-by-step</h3><p name="eb1a" id="eb1a" class="graf graf--p graf-after--h3">The specification above is split logically into 4 sections:</p><ul class="postList"><li name="06f5" id="06f5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Preamble: </strong>Consists of <strong class="markup--strong markup--li-strong">behavior</strong> and <strong class="markup--strong markup--li-strong">interface</strong> headers. States behavior (intended!) of what function and from which contract we are about to describe;</li><li name="fa53" id="fa53" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Types:</strong> a section with declarations of auxiliary variables;</li><li name="de34" id="de34" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Statements of our semantic claim:</strong> here are described under the <strong class="markup--strong markup--li-strong">storage </strong>header;</li><li name="fbf6" id="fbf6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Assumptions of our semantic claim: </strong>covered by two headers: <strong class="markup--strong markup--li-strong">iff</strong> and <strong class="markup--strong markup--li-strong">if</strong>.</li></ul><h3 name="decb" id="decb" class="graf graf--h3 graf-after--li">Preamble</h3><p name="f7dd" id="f7dd" class="graf graf--p graf-after--h3">The syntax is as follows:</p><figure name="0220" id="0220" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/a1cad77e04458d86cf40322e3e29d8da.js.js"></script></figure><p name="901a" id="901a" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="b98d" id="b98d" class="graf graf--li graf-after--p">&lt;name&gt; — stands for our name for our described semantics, for informative purposes only. It does not need to be the same as the name of the function, as in our case;</li><li name="53aa" id="53aa" class="graf graf--li graf-after--li">&lt;Contract&gt; — identifies the name of considerate contract;</li><li name="2ff1" id="2ff1" class="graf graf--li graf-after--li">&lt;function&gt; — identifies the name and the interface of considerate function.</li></ul><p name="368a" id="368a" class="graf graf--p graf-after--li">So, in our case, we declare that we are starting the description of intended behavior of a function <strong class="markup--strong markup--p-strong">transfer</strong> from the contract <strong class="markup--strong markup--p-strong">Token</strong>.</p><h3 name="067b" id="067b" class="graf graf--h3 graf-after--p">Types</h3><p name="c5df" id="c5df" class="graf graf--p graf-after--h3">Types are our internal variables used only for the purpose of our specification. We use EVM types here. In our case, we declared <em class="markup--em markup--p-em">FromBal</em> and <em class="markup--em markup--p-em">ToBal</em>, both uint256 integers.</p><h3 name="b3f8" id="b3f8" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Assumptions</strong></h3><p name="5e05" id="5e05" class="graf graf--p graf-after--h3">We will now focus on assumptions that are at the bottom of the spec, specifically under headers <strong class="markup--strong markup--p-strong">iff</strong> and <strong class="markup--strong markup--p-strong">if</strong>. The meaning of this section is slightly unintuitive:</p><p name="b58f" id="b58f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">iff</strong> &lt;<em class="markup--em markup--p-em">condition</em>&gt; — states intention that <em class="markup--em markup--p-em">condition</em> is either true or execution will revert;</p><p name="a568" id="a568" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">if</strong> &lt;<em class="markup--em markup--p-em">condition</em>&gt; — states intention that we care only about the case when the <em class="markup--em markup--p-em">condition</em> is true.</p><p name="e756" id="e756" class="graf graf--p graf-after--p">Note that in our example we have a somewhat complex condition for <strong class="markup--strong markup--p-strong">iff.</strong></p><figure name="1688" id="1688" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/1692f1b804adfc03639d9b1a91b610b0.js.js"></script></figure><p name="b24e" id="b24e" class="graf graf--p graf-after--figure">The construction above states that values of all <em class="markup--em markup--p-em">&lt;expression_i&gt;</em> fit inside range of <em class="markup--em markup--p-em">&lt;type&gt;</em> (i.e. no overflows happen).</p><p name="2716" id="2716" class="graf graf--p graf-after--p">In our case: both<strong class="markup--strong markup--p-strong"> (FromBal-Value)</strong> and<strong class="markup--strong markup--p-strong"> (ToBal+Value)</strong> must contain in the range of uint256.</p><p name="7d3f" id="7d3f" class="graf graf--p graf-after--p">The condition for <strong class="markup--strong markup--p-strong">if</strong> is much simpler. It just states that <strong class="markup--strong markup--p-strong">CALLER_ID</strong> is different from <strong class="markup--strong markup--p-strong">To</strong>, where <strong class="markup--strong markup--p-strong">CALLER_ID</strong> denotes the address of the caller of the transfer function.</p><h4 name="b09b" id="b09b" class="graf graf--h4 graf-after--p">About assumptions more formally</h4><p name="30e2" id="30e2" class="graf graf--p graf-after--h4">Intuitive meaning for semantics is the following: if assumptions are met before the execution of the function, then — after the execution — all the statements must hold.</p><p name="6d07" id="6d07" class="graf graf--p graf-after--p">Here, this is <em class="markup--em markup--p-em">almost</em> true. A small hook is in the fact, that the assumptions part is divided into <strong class="markup--strong markup--p-strong">if</strong> and <strong class="markup--strong markup--p-strong">iff</strong> part. Formally, it works the following way:</p><figure name="8899" id="8899" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/65014f2712d93543450fa274af516daa.js.js"></script></figure><p name="864d" id="864d" class="graf graf--p graf-after--figure">denotes that:</p><blockquote name="2902" id="2902" class="graf graf--blockquote graf-after--p">if — at the beginning — both A and B hold, then the execution finishes with success and afterwards all <strong class="markup--strong markup--blockquote-strong">Statements</strong> holds;</blockquote><blockquote name="4556" id="4556" class="graf graf--blockquote graf-after--blockquote">if — at the beginning — B holds and A doesn’t hold, then the execution finishes with a REVERT;</blockquote><blockquote name="53ab" id="53ab" class="graf graf--blockquote graf-after--blockquote">the case when B does not hold is not covered by the considerated semantics.</blockquote><h3 name="c516" id="c516" class="graf graf--h3 graf-after--blockquote">Statements</h3><p name="31a7" id="31a7" class="graf graf--p graf-after--h3">In our case, statements section is described only by two clauses, both under <strong class="markup--strong markup--p-strong">storage</strong> header. In general, other headers are possible (<strong class="markup--strong markup--p-strong">stack</strong>, <strong class="markup--strong markup--p-strong">pc -</strong>program counter), but let’s focus precisely on what we have:</p><figure name="92fd" id="92fd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/99e7f0f94a98fe0a7808ad135d3a5acd.js.js"></script></figure><p name="63d6" id="63d6" class="graf graf--p graf-after--figure">A line &lt;<strong class="markup--strong markup--p-strong">X&gt; |-&gt; &lt;Y&gt; =&gt; &lt;Z&gt; </strong>can be stated informally as:</p><p name="d80b" id="d80b" class="graf graf--p graf-after--p">If we denote the value of the memory (before the execution) at address &lt;<strong class="markup--strong markup--p-strong">X&gt;</strong> with &lt;<strong class="markup--strong markup--p-strong">Y&gt;</strong>, then it is equal to &lt;<strong class="markup--strong markup--p-strong">Z&gt;</strong> after the execution.</p><blockquote name="e7dd" id="e7dd" class="graf graf--blockquote graf-after--p">Unobvious aspect of the above notation is hidden in the declaration of &lt;X&gt;. The issue comes from the fact that our semantics are verified not with the source code but with the corresponding bytecode of the contract. It means that we cannot refer directly to variables (<strong class="markup--strong markup--blockquote-strong">balanceOf</strong>, <strong class="markup--strong markup--blockquote-strong">totalSupply</strong>) but we need to provide the storage address(or key in ethereum storage Merkle Patricia trie if you will) that keeps the data (here we refer to low-level implementation of EVM). This is somewhat complicated (especially for maps) and the details can be found <a href="https://github.com/dapphub/klab/blob/master/acts.md#storage" data-href="https://github.com/dapphub/klab/blob/master/acts.md#storage" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">[here]</a>. For our purposes it is sufficient to know that element of index <strong class="markup--strong markup--blockquote-strong">i</strong> in a map <strong class="markup--strong markup--blockquote-strong">balanceOf</strong> in our contract is kept in the Merkle tree at position <strong class="markup--strong markup--blockquote-strong">hash(0 + i)</strong> which is denoted as <strong class="markup--strong markup--blockquote-strong">#hashedLocation(“Solidity”, 0, i)</strong> in language K (that is underneath ACT). <strong class="markup--strong markup--blockquote-strong">0 </strong>comes from <strong class="markup--strong markup--blockquote-strong">balanceOf</strong> being the very first variable declaration in the contract<strong class="markup--strong markup--blockquote-strong">. </strong>At this point you might be a bit lost since in the spec file you can see for example <strong class="markup--strong markup--blockquote-strong">#Token.balances[To]</strong> that seems to refer directly to the variable <strong class="markup--strong markup--blockquote-strong">balanceOf</strong>. This is however only an illusion since in the file <a href="https://github.com/dapphub/klab/blob/master/examples/token/src/storage.md" data-href="https://github.com/dapphub/klab/blob/master/examples/token/src/storage.md" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">klab/examples/token/src/storage.md</a></blockquote><figure name="bc7e" id="bc7e" class="graf graf--figure graf--iframe graf-after--blockquote"><script src="https://gist.github.com/tkazana-eth/7ae47aba6eb5d103becddecf3beaf7ed.js.js"></script></figure><blockquote name="23a6" id="23a6" class="graf graf--blockquote graf-after--figure">you see a macro that translates this expression into to actual address. This is written in K language. We will dig into K in future posts.</blockquote><h3 name="96ea" id="96ea" class="graf graf--h3 graf-after--blockquote">The high-level semantics: altogether</h3><p name="1d24" id="1d24" class="graf graf--p graf-after--h3">Finally, the<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> intended semantics described in the spec file</em></strong> might be in informally expressed as follows:</p><blockquote name="e52d" id="e52d" class="graf graf--blockquote graf-after--p">The behaviour of <strong class="markup--strong markup--blockquote-strong">transfer(address To, uint Value)</strong> when the address of the caller is equal to <strong class="markup--strong markup--blockquote-strong">To</strong> is undefined. So we assume that <strong class="markup--strong markup--blockquote-strong">CALLER_ID</strong> is always different from <strong class="markup--strong markup--blockquote-strong">To</strong>. Then, if either <strong class="markup--strong markup--blockquote-strong">(balanceOf[To] + Value)</strong> or <strong class="markup--strong markup--blockquote-strong">(balanceOf[CALLER_ID]-Value)</strong> falls out of range of uint256, the function finishes wit <strong class="markup--strong markup--blockquote-strong">REVERT</strong>. Finally, if both above expressions are in range of uint256, then the value of <strong class="markup--strong markup--blockquote-strong">balanceOf[CALLER_ID]</strong> decreases by <strong class="markup--strong markup--blockquote-strong">Value</strong>, and <strong class="markup--strong markup--blockquote-strong">balances[To]</strong> increases by <strong class="markup--strong markup--blockquote-strong">Value</strong>.</blockquote><h3 name="7061" id="7061" class="graf graf--h3 graf-after--blockquote">3, 2, 1 …Action!</h3><p name="5940" id="5940" class="graf graf--p graf-after--h3">Let’s check (automatically!) if the above semantics is corresponding to the actual code. We need to:</p><ol class="postList"><li name="e278" id="e278" class="graf graf--li graf-after--p">Compile the source file into the bytecode. The result is already here:<br><a href="https://github.com/dapphub/klab/blob/master/examples/token/dapp/out/token.sol.json" data-href="https://github.com/dapphub/klab/blob/master/examples/token/dapp/out/token.sol.json" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">klab/examples/token/dapp/out/token.sol.json<br></a>If you wish to repeat this step by yourself, remember to compile with the flags:</li></ol><figure name="ba23" id="ba23" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/tkazana-eth/2a8de621cfeec83e4238cc18f587c144.js.js"></script></figure><p name="5e0b" id="5e0b" class="graf graf--p graf-after--figure">2. Build K statements from the bytecode and semantics. You can do that by running</p><figure name="03ae" id="03ae" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/marekkirejczyk/5e63193ff96c0c6e5797dd00ea959c48.js"></script></figure><p name="bfe6" id="bfe6" class="graf graf--p graf-after--figure">inside the directory examples/token. The result will be visible at examples/token/out/specs.</p><blockquote name="0a8c" id="0a8c" class="graf graf--blockquote graf-after--p">To reproduce the above step you need to have <strong class="markup--strong markup--blockquote-strong">klab</strong> installed. (A detailed tutorial for this is at k<a href="https://github.com/dapphub/klab#setting-up-klab-server-and-client" data-href="https://github.com/dapphub/klab#setting-up-klab-server-and-client" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">lab GitHub</a>)</blockquote><p name="dd75" id="dd75" class="graf graf--p graf-after--blockquote">3. Run the machinery. KLAB uses a client-server architecture, so you need to run two processes (same as above, klab must be installed):</p><p name="c75e" id="c75e" class="graf graf--p graf-after--p">Server:</p><figure name="34b6" id="34b6" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/6408bf3e349e4b8411d5e443461dd59e.js.js"></script></figure><p name="fe1e" id="fe1e" class="graf graf--p graf-after--figure">Client:</p><figure name="fae2" id="fae2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/1a791159be27dab4faec9e313f457d77.js.js"></script></figure><p name="864e" id="864e" class="graf graf--p graf-after--figure">(it may take a while: on my MacBookAir it took ~10 minutes)</p><p name="2c95" id="2c95" class="graf graf--p graf-after--p">Please note, that — in step 2 — the description compiled into two different K statements (i.e. one statement describes the case when <strong class="markup--strong markup--p-strong">iff</strong> section holds and the other — when it fails). So, to verify our semantics, these K statements have to <strong class="markup--strong markup--p-strong">both pass</strong>. That is also why the client above runs two tests, one after the other.</p><h3 name="dd1f" id="dd1f" class="graf graf--h3 graf-after--p">So: what have we just proved?</h3><p name="085b" id="085b" class="graf graf--p graf-after--h3">If both above K statements passed the klab verification, it means that the considerate code really behaves exactly as described in our semantics. Well, a precisian would add: unless there is a bug in underneath KEVM description of EVM, or there is a bug in K-framework itself ;)</p><h3 name="ff93" id="ff93" class="graf graf--h3 graf-after--p">What next?</h3><p name="a529" id="a529" class="graf graf--p graf-after--h3">Homework recommendation :)</p><p name="8ea8" id="8ea8" class="graf graf--p graf-after--p">1. Try to spoil the implementation (for example remove safe math operations) and re-run the proving process to make sure that the proof will fail.</p><p name="a097" id="a097" class="graf graf--p graf-after--p">2. Try to write a high-level semantics for the same function, but for the not-yet-covered case, i.e. <strong class="markup--strong markup--p-strong">CALLER_ID == To</strong> and verify if it is consistent with the actual code.</p><p name="e316" id="e316" class="graf graf--p graf-after--p">3. See <a href="https://github.com/dapphub/fv-tutorial.git" data-href="https://github.com/dapphub/fv-tutorial.git" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/dapphub/fv-tutorial.git</a> — a great set of tasks prepared by dapphub for Devcon4 workshop. Here the problem is reversed to the above problem 1. Given implementations and specifications that do <em class="markup--em markup--p-em">not agree</em> with each other, try to fix it.</p><h4 name="716f" id="716f" class="graf graf--h4 graf-after--p">Acknowledgments</h4><p name="0c88" id="0c88" class="graf graf--p graf-after--h4 graf--trailing"><em class="markup--em markup--p-em">Thanks to Tomasz Kazana for his support and contribution to this post.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@marekkirejczyk" class="p-author h-card">Marek Kirejczyk</a> on <a href="https://medium.com/p/74085f5cd6c1"><time class="dt-published" datetime="2019-02-02T18:20:54.752Z">February 2, 2019</time></a>.</p><p><a href="https://medium.com/@marekkirejczyk/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 22, 2025.</p></footer></article></body></html>