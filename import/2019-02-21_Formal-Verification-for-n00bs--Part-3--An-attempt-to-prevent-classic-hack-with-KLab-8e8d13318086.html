<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with KLab</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with KLab</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is the third post of a series Formal Verification for n00bs:
Part 1: The K ecosystem
Part 2: Proving the correctness of a token
Part…
</section>
<section data-field="body" class="e-content">
<section name="9509" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="14e2" id="14e2" class="graf graf--h3 graf--leading graf--title">Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with Act</h3><figure name="a604" id="a604" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*cKTz2GyNJ2I3ereGFcpR0Q.jpeg" data-width="4198" data-height="2551" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*cKTz2GyNJ2I3ereGFcpR0Q.jpeg"></figure><p name="679c" id="679c" class="graf graf--p graf-after--figure">This is the third post of a series Formal Verification for n00bs:<br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--p-anchor" target="_blank">Part 1: The K ecosystem</a><br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">Part 2: Proving the correctness of a token</a><br>Part 3: A try to prevent classic hack with KLab<br><a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-4-understanding-k-language-6069c20cfd47" class="markup--anchor markup--p-anchor" target="_blank">Part 4: Understanding K language</a></p><p name="3314" id="3314" class="graf graf--p graf-after--p">In this post, we will try to use KLab to show how a classic hack - Batch overflow could be prevented. We will also explore ACT in more details as well as reach some of its limitations.</p><blockquote name="75de" id="75de" class="graf graf--blockquote graf-after--p">Reminder:<br>ACT is a fairly simple language provided by KLAB that helps in generating high-level semantics in K. The whole ecosystem is described in <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--blockquote-anchor" target="_blank">part1</a>; some basics on ACT were already described in <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--blockquote-anchor" target="_blank">part2</a>.</blockquote><h3 name="4356" id="4356" class="graf graf--h3 graf-after--blockquote">A tragedy that could be avoided</h3><p name="6ed4" id="6ed4" class="graf graf--p graf-after--h3">In the history of Ethereum, there were a few big hacks caused by implementation issues in smart contracts. One of the famous was the one with <a href="https://blog.matryx.ai/batch-overflow-bug-on-ethereum-erc20-token-contracts-and-safemath-f9ebcc137434" data-href="https://blog.matryx.ai/batch-overflow-bug-on-ethereum-erc20-token-contracts-and-safemath-f9ebcc137434" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">batch</a> <a href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536" data-href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536" class="markup--anchor markup--p-anchor" target="_blank">overflow</a>. We want to show that this problem could be avoided if formal verification had been used.</p><p name="0c0a" id="0c0a" class="graf graf--p graf-after--p">The code of the considerate contract is <a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" data-href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. The problem is in the following function:</p><figure name="9439" id="9439" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/8671c4fae2df01eff9fa26de040c1465.js.js"></script></figure><p name="c151" id="c151" class="graf graf--p graf-after--figure">The vulnerability is caused by code in line 3, where SafeMath should have been used:</p><blockquote name="693c" id="693c" class="graf graf--blockquote graf-after--p">The attack for the original code is the following: you can pick a huge <strong class="markup--strong markup--blockquote-strong">_value</strong> such that for example <strong class="markup--strong markup--blockquote-strong">(2 * _value)</strong> overflows the range of <strong class="markup--strong markup--blockquote-strong">uint256, e.g. <br>_value = MAX_INT/2+1<br></strong>This will casue <strong class="markup--strong markup--blockquote-strong">amount to equal 2 </strong>and will bypasschecks in line 5, while amount added to receiver in line 9 will be much bigger than amount of all tokens in circulation.</blockquote><p name="2b0e" id="2b0e" class="graf graf--p graf-after--blockquote">Could this bug be noticed earlier? Let’s write high-level <strong class="markup--strong markup--p-strong">intended </strong>semantics for the <em class="markup--em markup--p-em">batchTransfer</em> function and check if it is consistent with the actual code.</p><blockquote name="7e42" id="7e42" class="graf graf--blockquote graf-after--p">Note: We have to change the interface of the <em class="markup--em markup--blockquote-em">batchTransfer</em> function since at this particular moment dynamic arrays are not yet supported by KLab. So, we will alter solidity code:</blockquote><figure name="1638" id="1638" class="graf graf--figure graf--iframe graf-after--blockquote"><script src="https://gist.github.com/tkazana-eth/21bafc0513510a8e3edeb1b57f3b9410.js.js"></script></figure><p name="d894" id="d894" class="graf graf--p graf-after--figure">The announced above high-level semantics for the <em class="markup--em markup--p-em">batchTransfer</em> function is as follows:</p><figure name="6d7c" id="6d7c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/8b7381a10901002e697c0610042d4b51.js.js"></script></figure><p name="2c60" id="2c60" class="graf graf--p graf-after--figure">As an exercise, you can try to check that the above implementation of <em class="markup--em markup--p-em">batchTransfer</em> function fails the proof of consistency with the semantics, however after fixing the bug in line 5 — it passes.</p><p name="8b40" id="8b40" class="graf graf--p graf-after--p">The fixed code is here:</p><figure name="958e" id="958e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/c814c14fc50cf74824ccdc8fa975ff1a.js.js"></script></figure><p name="6126" id="6126" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Watch out: the proof for the above on my MacBook Air took ~3 hours!</em></p><h4 name="4960" id="4960" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="6d86" id="6d86" class="graf graf--p graf-after--h4">This example shows how formal verification could prevent the hack. It also shows the limitations of practical verification with ACT.</p><h3 name="6ed5" id="6ed5" class="graf graf--h3 graf-after--p">ACT cheatsheet</h3><p name="f6c8" id="f6c8" class="graf graf--p graf-after--h3">As we reached the first limitations of ACT it seems like a good moment to see what is the list of all available headers.</p><p name="2f75" id="2f75" class="graf graf--p graf-after--p">In <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1" class="markup--anchor markup--p-anchor" target="_blank">part2</a> of this series we described the general structure of a specification written in ACT, in particular, three headers: IF, IFF (particularly to express assumptions) and STORAGE. More headers below:</p><h4 name="3fc5" id="3fc5" class="graf graf--h4 graf-after--p">SUCH THAT</h4><p name="4ad1" id="4ad1" class="graf graf--p graf-after--h4">This is used solely to express constraints for statements (S). Let us see an example (special thanks to MrChico from dapphub for this example; all following examples are from official dapphub materials):</p><figure name="d85d" id="d85d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/7ef9b21fb79f8e65f044d29197c1acf8.js.js"></script></figure><p name="1960" id="1960" class="graf graf--p graf-after--figure">As you can see the above specifies that a function <em class="markup--em markup--p-em">change</em> behaves in such a way that it modifies two particular positions at the storage (0 and 1 stands for the first two variables of the code of the function) with the constraint that the final values must sum up to the input value x.</p><h4 name="de98" id="de98" class="graf graf--h4 graf-after--p">GAS</h4><p name="7c37" id="7c37" class="graf graf--p graf-after--h4">You can specify accurate usage of your gas:</p><figure name="cc78" id="cc78" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/d7a96db23af34dc0d0fc30507fc6649d.js.js"></script></figure><h4 name="71f8" id="71f8" class="graf graf--h4 graf-after--figure">STACK</h4><p name="0887" id="0887" class="graf graf--p graf-after--h4">You can specify direct changes to stack:</p><figure name="1eb8" id="1eb8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/b81ab0087e1a3b1d114834463a2c0d84.js.js"></script></figure><h4 name="c760" id="c760" class="graf graf--h4 graf-after--figure">CALLS</h4><p name="f2bd" id="f2bd" class="graf graf--p graf-after--h4">You can specify that an external function is called.</p><figure name="e517" id="e517" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/77b7ccf84aaf3f947ee64c76b9d05b0a.js.js"></script></figure><h4 name="1f7a" id="1f7a" class="graf graf--h4 graf-after--figure">RETURNS</h4><p name="db9c" id="db9c" class="graf graf--p graf-after--h4">You can specify what is returned by your function:</p><figure name="0c3b" id="0c3b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tkazana-eth/117e22541fc35d4192dbb193157360c5.js.js"></script></figure><h4 name="dd78" id="dd78" class="graf graf--h4 graf-after--figure">BALANCE</h4><p name="d595" id="d595" class="graf graf--p graf-after--h4">You should be able to specify that a balance of a specific address is somehow changed. However, this is not yet available in KLab.</p><h3 name="8415" id="8415" class="graf graf--h3 graf-after--p">Act vs K</h3><p name="e6db" id="e6db" class="graf graf--p graf-after--h3">KLab gives a great promise for a solid, reliable tool for formal verification. However, it is a tool on an early stage and there are significant limitations: lack of support for account balance or arrays are two examples. To be able to efficiently obtain a proof of correctness, one has to write Solidity code in a specific manner:</p><ul class="postList"><li name="8a81" id="8a81" class="graf graf--li graf-after--p">All functions should be short and do just one specific thing. If you have a complicated multi-purpose function in your contract, we recommend splitting into a few smaller specialized functions.</li><li name="264c" id="264c" class="graf graf--li graf-after--li">Calls to unknown code should be avoided.</li><li name="03f4" id="03f4" class="graf graf--li graf-after--li">The code should be as simple and straightforward as possible.</li></ul><p name="ee78" id="ee78" class="graf graf--p graf-after--li">KLab is an upper layer of a stack of technologies (Details: <a href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" data-href="https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383" class="markup--anchor markup--p-anchor" target="_blank">part1</a>). Directly underneath KLab, there is a language K, in which we can also state our high-level semantics.</p><p name="a1de" id="a1de" class="graf graf--p graf-after--p">K is a more expressive language but comes with its own trade-offs:</p><ul class="postList"><li name="e420" id="e420" class="graf graf--li graf-after--p">K’s prover outputs just TRUE or FALSE, while KLab’s prover is equipped with a graphical debugger that helps to find a counterexample for a failed proof. (We will cover debugger in a future blog post)</li><li name="a306" id="a306" class="graf graf--li graf-after--li">Second, to write directly in K, one has to understand accurately EVM (more specifically: KEVM, which description of EVM written in K) which isn’t a piece of cake.</li></ul><p name="7841" id="7841" class="graf graf--p graf-after--li">So that reality of today’s formal verification of EVM code is that one should understand both ACT and K to be efficient.</p><p name="fa33" id="fa33" class="graf graf--p graf-after--p graf--trailing">And so: next time, we will give you a smooth introduction to K!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@marekkirejczyk" class="p-author h-card">Marek Kirejczyk</a> on <a href="https://medium.com/p/8e8d13318086"><time class="dt-published" datetime="2019-02-21T10:57:21.337Z">February 21, 2019</time></a>.</p><p><a href="https://medium.com/@marekkirejczyk/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 22, 2025.</p></footer></article></body></html>